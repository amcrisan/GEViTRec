---
title: "GEViTRec"
author: "Anamaria Crisan"
date: '2019-02-01'
output: html_document
---


## Loading data
```{r}
devtools::load_all() #temporary once things are done

#Table data
tab_dat<-input_data(file = system.file("./inst/extdata/", "ebov_metadata.csv", package = "epivis"),dataType = "table")

#Tree data
tree_dat<-input_data(file = system.file("./inst/extdata/", "ebov_tree.nwk", package = "epivis"),dataType = "tree")

#Genomic data
genomic_dat<-input_data(file = system.file("./inst/extdata/", "ebov_GIN_genomic.fasta", package = "epivis"),dataType = "dna")

#Shape files
#Shape files require that .shp,.shx,and .prj files at a minimun to be in the same directory
#to add metadata to the shape file, you can also add .dbf files
gin_shape_dat<-input_data(file = system.file("./inst/extdata/", "gin_admbnda_adm1_ocha_itos.shp", package = "epivis"),dataType = "spatial")
lbr_shape_dat<-input_data(file = system.file("./inst/extdata/", "lbr_admbnda_adm1_ocha.shp", package = "epivis"),dataType = "spatial")
sle_shape_dat<-input_data(file = system.file("./inst/extdata/", "sle_admbnda_adm1_1m_gov_ocha_20161017.shp",package = "epivis"),dataType = "spatial")
```

## Data Harmonization
```{r}
harmon_obj<-data_harmonization(tab_dat,tree_dat,genomic_dat,gin_shape_dat,lbr_shape_dat,sle_shape_dat)
```

It's possible to view the entityt graph of how all of the data sources are linked together
```{r}
view_entity_graph(harmon_obj[["entityGraph"]])
```

It's also possible to filter according to the strength of the jaccard distance strength. A strength of 1 means that two variables in different datasets are effectively the same (have set equality), whereas 0 means that they have nothing in common.
```{r}
view_entity_graph(subset_graph(harmon_obj[["entityGraph"]],1))
```

## Chart Recommendations

With the data harmonized, it is possible to generate specifications for different charts. It possible to use the whole graph too.

### Temporary - sorting out few functions

```{r}
load("../../R/sysdata.rda")

objMeta<-harmon_obj[["dataMeta"]]
obj<-harmon_obj[["dataObj"]]
entity_graph<-harmon_obj[["entityGraph"]]

datOnly<-dplyr::filter(objMeta,dataEntity == "dataType")

E(entity_graph)$weight<-1-as.numeric(E(entity_graph)$weights)

entity_graph_table<-as_tibble(entity_graph)

usrChoices<-c() #the user can state which variables should be in the visualization

#number of data types per component
component_info<- entity_graph_table %>%
  dplyr::filter(dataEntity == "dataType") %>%
  dplyr::group_by(component) %>%
  dplyr::count() %>%
  dplyr::arrange(desc(n))

spec_list_all<-c()
for(comp in component_info$component){
  comp_info<-dplyr::filter(component_info,component == comp)
  
  #for each component, try to produce at most two
  #visualizations
  max_vis<-2
  if(comp_info$n>1){
    #the hard coded numbers here are abitrary
    max_vis<-ifelse(comp_info$n*2<10,10,comp_info$n*2)
  }
  
  #get the relevant data for each component
  comp_var<-dplyr::filter(entity_graph_table,dataEntity=="feild") %>%
    dplyr::filter(component == comp)
  
  comp_data<-dplyr::filter(entity_graph_table,dataEntity=="dataType") %>%
    dplyr::filter(component == comp)
  
  #Find paths between variables as these are essential
  #seeds for the specifications
  dats<-as.numeric(V(entity_graph)[as.character(comp_data$name)])
  dat_paths<-igraph::all_shortest_paths(entity_graph,from=dats,to=dats)$res
  
  #rank paths according to the number of visualizations linked
  #and the strength of the path - favour strongly connected paths
  pathRank<-sapply(dat_paths,function(path_val,scoring_table){
    VP = as.numeric(path_val)
    EP = rep(VP, each=2)[-1]
    EP = EP[-length(EP)]
    
    #a perfectly aligned path has a weight of one, because everything is a strong connection
    strength_var<-sum(E(entity_graph)$weight[get.edge.ids(entity_graph, EP)])/(length(VP)-1)
    
    if(is.nan(strength_var)){ strength_var <- 0} #try to avoid single charts
   
    #rate the path by the high relevance chart types
    datTypes<-dplyr::filter(datOnly,dataID %in% as_ids(path_val)) %>%
      dplyr::inner_join(chart_scores,by=c("dataType" = "dataSource")) %>%
      group_by(dataID) %>%
      do(summarise(.,max(rescale)))
    
    diversity<-nrow(datTypes)
    relevance<-sum(datTypes$`max(rescale)`)
    score = (diversity*relevance)*strength_var
    
    return(c(score,strength_var,diversity,relevance))

  },scoring_table = chart_scores) %>% t() %>% data.frame(.,stringsAsFactors=FALSE)
  
  colnames(pathRank)<-c("score","strength","diversity","relevance")
  pathRank$pathIndex<-1:length(dat_paths)
  
  #for now - choose the top path
  #top-two paths for each component
  #consider making this more variable if path lengths are store ect..
  pathRank<- pathRank %>% arrange(desc(strength),desc(score)) %>% head(4)
  
  #convert the path into a specification for a chart or two
  for(idx in pathRank$pathIndex){
    print(idx)
    path_var<-as_ids(dat_paths[[idx]])
    
    dats<-dplyr::filter(datOnly,dataID %in% path_var)
    vars<-dplyr::filter(entity_graph_table,dataSource %in% as.character(dats$dataID)) %>% 
      dplyr::filter(dataEntity == "feild")
    
    required<-path_var[path_var %in% vars$name]
    
    #add some more context to the variables
    #so that its possible further refine what they
    #are assigned to, espeically categorical variables
    #with a larger number of variables that really
    #don't do well assigned to colour
    #for(var in vars$name){
    vars$feild_detail<-sapply(vars$name,function(var,vars,obj,objMeta){
      tmp<-dplyr::filter(vars,name == var)
      tmp<-get_feild_details(feild = tmp$name,
                        feild_type = tmp$dataType,
                        datSource = tmp$dataSource,
                        obj = obj,
                        meta = objMeta)  
    },vars = vars,obj = obj, objMeta = objMeta) %>% unname()
    
    total_quant = dplyr::filter(vars,feild_detail %in% c("quant","qual-pos")) %>% count()
    total_qual = dplyr::filter(vars,!feild_detail %in% c("quant","qual-pos")) %>% count()

    
    #small test case - specs for each table
    if(total_quant$n > 0 | total_qual$n>0){
       spec_list<-assign_vars(datFeilds = vars,
                              require_var = required,
                              n_quant=ifelse(total_quant$n>3,3,total_quant$n),
                              n_qual=ifelse(total_qual$n>2,2,total_qual$n))
       rep_len<-ifelse(is.null(dim(spec_list)),1,nrow(spec_list))
       if(rep_len == 1){
         if(!is.null(spec_list)){
           spec_list<-c(comp,idx,spec_list)
         }
       }else{
         spec_list<-cbind(rep(comp,rep_len),rep(idx,rep_len),spec_list)
       }
       spec_list_all<-rbind(spec_list_all,spec_list)
    }
  }
}
```

Using the example below, there are a total of 300 possible combinations of specifications, but when we apply the constraints on the graph for nodes with high degrees that connect information, there are now suddenly only 9 specifications that we care about. MUCH MUCH more mangeable.

Can futher narrow it down if the user has provided variables they care about, then you only want those kinds of combinations - but, actually would be good to show both and just rank the user required ones higher

Also - write out the math for this to prove this assertion because it will help in the paper


For most chart types, positional variables will already be take up (like a phylogenetic tree), and so the quantiative positional variables don't matter, but non-positional channels can be added via other variables if the chart type has its own metadata, or is linked to another variable that does with a direct link.